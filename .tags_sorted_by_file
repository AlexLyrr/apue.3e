!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
DIRS	Makefile	/^DIRS = lib intro sockets advio daemons datafiles db environ \\$/;"	m
EXTRALIBS	advio/Makefile	/^  EXTRALIBS=-lrt$/;"	m
MOREPROGS	advio/Makefile	/^MOREPROGS = rot13c2$/;"	m
PLATFORM	advio/Makefile	/^PLATFORM=$(shell $(ROOT)\/systype.sh)$/;"	m
PROGS	advio/Makefile	/^PROGS =	deadlock mandatory mcopy2 nonblockw rot13a$/;"	m
ROOT	advio/Makefile	/^ROOT=..$/;"	m
lockabyte	advio/deadlock.c	/^lockabyte(const char *name, int fd, off_t offset)$/;"	f	file:
main	advio/deadlock.c	/^main(void)$/;"	f
lockfile	advio/lockfile.c	/^lockfile(int fd)$/;"	f
main	advio/mandatory.c	/^main(int argc, char *argv[])$/;"	f
COPYINCR	advio/mcopy2.c	5;"	d	file:
main	advio/mcopy2.c	/^main(int argc, char *argv[])$/;"	f
buf	advio/nonblockw.c	/^char	buf[500000];$/;"	v
main	advio/nonblockw.c	/^main(void)$/;"	f
readn	advio/readn.c	/^readn(int fd, void *ptr, size_t n)$/;"	f
BSZ	advio/rot13a.c	5;"	d	file:
buf	advio/rot13a.c	/^unsigned char buf[BSZ];$/;"	v
main	advio/rot13a.c	/^main(int argc, char* argv[])$/;"	f
translate	advio/rot13a.c	/^translate(unsigned char c)$/;"	f
BSZ	advio/rot13c2.c	7;"	d	file:
NBUF	advio/rot13c2.c	8;"	d	file:
READ_PENDING	advio/rot13c2.c	/^	READ_PENDING = 1,$/;"	e	enum:rwop	file:
UNUSED	advio/rot13c2.c	/^	UNUSED = 0,$/;"	e	enum:rwop	file:
WRITE_PENDING	advio/rot13c2.c	/^	WRITE_PENDING = 2$/;"	e	enum:rwop	file:
aiocb	advio/rot13c2.c	/^	struct aiocb  aiocb;$/;"	m	struct:buf	typeref:struct:buf::aiocb	file:
buf	advio/rot13c2.c	/^struct buf {$/;"	s	file:
bufs	advio/rot13c2.c	/^struct buf bufs[NBUF];$/;"	v	typeref:struct:buf
data	advio/rot13c2.c	/^	unsigned char data[BSZ];$/;"	m	struct:buf	file:
last	advio/rot13c2.c	/^	int           last;$/;"	m	struct:buf	file:
main	advio/rot13c2.c	/^main(int argc, char* argv[])$/;"	f
op	advio/rot13c2.c	/^	enum rwop     op;$/;"	m	struct:buf	typeref:enum:buf::rwop	file:
rwop	advio/rot13c2.c	/^enum rwop {$/;"	g	file:
translate	advio/rot13c2.c	/^translate(unsigned char c)$/;"	f
writen	advio/writen.c	/^writen(int fd, const void *ptr, size_t n)$/;"	f
PLATFORM	daemons/Makefile	/^PLATFORM=$(shell $(ROOT)\/systype.sh)$/;"	m
ROOT	daemons/Makefile	/^ROOT=..$/;"	m
daemonize	daemons/init.c	/^daemonize(const char *cmd)$/;"	f
main	daemons/reread.c	/^main(int argc, char *argv[])$/;"	f
mask	daemons/reread.c	/^sigset_t	mask;$/;"	v
reread	daemons/reread.c	/^reread(void)$/;"	f
thr_fn	daemons/reread.c	/^thr_fn(void *arg)$/;"	f
main	daemons/reread2.c	/^main(int argc, char *argv[])$/;"	f
reread	daemons/reread2.c	/^reread(void)$/;"	f
sighup	daemons/reread2.c	/^sighup(int signo)$/;"	f
sigterm	daemons/reread2.c	/^sigterm(int signo)$/;"	f
LOCKFILE	daemons/single.c	10;"	d	file:
LOCKMODE	daemons/single.c	11;"	d	file:
already_running	daemons/single.c	/^already_running(void)$/;"	f
PLATFORM	datafiles/Makefile	/^PLATFORM=$(shell $(ROOT)\/systype.sh)$/;"	m
PROGS	datafiles/Makefile	/^PROGS =	strftime$/;"	m
ROOT	datafiles/Makefile	/^ROOT=..$/;"	m
getpwnam	datafiles/getpwnam.c	/^getpwnam(const char *name)$/;"	f
main	datafiles/strftime.c	/^main(void)$/;"	f
COMM_OBJ	db/Makefile	/^COMM_OBJ = db.o$/;"	m
EXTRALD	db/Makefile	/^  EXTRALD=-R.$/;"	m
EXTRALD	db/Makefile	/^  EXTRALD=-Wl,-rpath=.$/;"	m
EXTRALD	db/Makefile	/^  EXTRALD=-m64 -R.$/;"	m
LDCMD	db/Makefile	/^  LDCMD=$(CC) -shared -Wl,-dylib -o libapue_db.so.1 -L$(ROOT)\/lib -lapue -lc db.o$/;"	m
LDCMD	db/Makefile	/^  LDCMD=$(LD) -64 -G -Bdynamic -R\/lib\/64:\/usr\/ucblib\/sparcv9 -o libapue_db.so.1 -L\/lib\/64 -L\/usr\/ucblib\/sparcv9 -L$(ROOT)\/lib -lapue db.o$/;"	m
LIBMISC	db/Makefile	/^LIBMISC	= libapue_db.a$/;"	m
PLATFORM	db/Makefile	/^PLATFORM=$(shell $(ROOT)\/systype.sh)$/;"	m
ROOT	db/Makefile	/^ROOT=..$/;"	m
DATLEN_MAX	db/apue_db.h	27;"	d
DATLEN_MIN	db/apue_db.h	26;"	d
DBHANDLE	db/apue_db.h	/^typedef	void *	DBHANDLE;$/;"	t
DB_INSERT	db/apue_db.h	17;"	d
DB_REPLACE	db/apue_db.h	18;"	d
DB_STORE	db/apue_db.h	19;"	d
IDXLEN_MAX	db/apue_db.h	25;"	d
IDXLEN_MIN	db/apue_db.h	24;"	d
_APUE_DB_H	db/apue_db.h	2;"	d
COUNT	db/db.c	/^typedef unsigned long	COUNT;	\/* unsigned counter *\/$/;"	t	file:
DB	db/db.c	/^} DB;$/;"	t	typeref:struct:__anon1	file:
DBHASH	db/db.c	/^typedef unsigned long	DBHASH;	\/* hash values *\/$/;"	t	file:
FREE_OFF	db/db.c	25;"	d	file:
HASH_OFF	db/db.c	26;"	d	file:
IDXLEN_SZ	db/db.c	13;"	d	file:
NEWLINE	db/db.c	16;"	d	file:
NHASH_DEF	db/db.c	24;"	d	file:
PTR_MAX	db/db.c	23;"	d	file:
PTR_SZ	db/db.c	22;"	d	file:
SEP	db/db.c	14;"	d	file:
SPACE	db/db.c	15;"	d	file:
_db_alloc	db/db.c	/^_db_alloc(int namelen)$/;"	f	file:
_db_dodelete	db/db.c	/^_db_dodelete(DB *db)$/;"	f	file:
_db_find_and_lock	db/db.c	/^_db_find_and_lock(DB *db, const char *key, int writelock)$/;"	f	file:
_db_findfree	db/db.c	/^_db_findfree(DB *db, int keylen, int datlen)$/;"	f	file:
_db_free	db/db.c	/^_db_free(DB *db)$/;"	f	file:
_db_hash	db/db.c	/^_db_hash(DB *db, const char *key)$/;"	f	file:
_db_readdat	db/db.c	/^_db_readdat(DB *db)$/;"	f	file:
_db_readidx	db/db.c	/^_db_readidx(DB *db, off_t offset)$/;"	f	file:
_db_readptr	db/db.c	/^_db_readptr(DB *db, off_t offset)$/;"	f	file:
_db_writedat	db/db.c	/^_db_writedat(DB *db, const char *data, off_t offset, int whence)$/;"	f	file:
_db_writeidx	db/db.c	/^_db_writeidx(DB *db, const char *key,$/;"	f	file:
_db_writeptr	db/db.c	/^_db_writeptr(DB *db, off_t offset, off_t ptrval)$/;"	f	file:
chainoff	db/db.c	/^  off_t  chainoff; \/* offset of hash chain for this index record *\/$/;"	m	struct:__anon1	file:
cnt_delerr	db/db.c	/^  COUNT  cnt_delerr;   \/* delete error *\/$/;"	m	struct:__anon1	file:
cnt_delok	db/db.c	/^  COUNT  cnt_delok;    \/* delete OK *\/$/;"	m	struct:__anon1	file:
cnt_fetcherr	db/db.c	/^  COUNT  cnt_fetcherr; \/* fetch error *\/$/;"	m	struct:__anon1	file:
cnt_fetchok	db/db.c	/^  COUNT  cnt_fetchok;  \/* fetch OK *\/$/;"	m	struct:__anon1	file:
cnt_nextrec	db/db.c	/^  COUNT  cnt_nextrec;  \/* nextrec *\/$/;"	m	struct:__anon1	file:
cnt_stor1	db/db.c	/^  COUNT  cnt_stor1;    \/* store: DB_INSERT, no empty, appended *\/$/;"	m	struct:__anon1	file:
cnt_stor2	db/db.c	/^  COUNT  cnt_stor2;    \/* store: DB_INSERT, found empty, reused *\/$/;"	m	struct:__anon1	file:
cnt_stor3	db/db.c	/^  COUNT  cnt_stor3;    \/* store: DB_REPLACE, diff len, appended *\/$/;"	m	struct:__anon1	file:
cnt_stor4	db/db.c	/^  COUNT  cnt_stor4;    \/* store: DB_REPLACE, same len, overwrote *\/$/;"	m	struct:__anon1	file:
cnt_storerr	db/db.c	/^  COUNT  cnt_storerr;  \/* store error *\/$/;"	m	struct:__anon1	file:
datbuf	db/db.c	/^  char  *datbuf; \/* malloc'ed buffer for data record*\/$/;"	m	struct:__anon1	file:
datfd	db/db.c	/^  int    datfd;  \/* fd for data file *\/$/;"	m	struct:__anon1	file:
datlen	db/db.c	/^  size_t datlen; \/* length of data record *\/$/;"	m	struct:__anon1	file:
datoff	db/db.c	/^  off_t  datoff; \/* offset in data file of data record *\/$/;"	m	struct:__anon1	file:
db_close	db/db.c	/^db_close(DBHANDLE h)$/;"	f
db_delete	db/db.c	/^db_delete(DBHANDLE h, const char *key)$/;"	f
db_fetch	db/db.c	/^db_fetch(DBHANDLE h, const char *key)$/;"	f
db_nextrec	db/db.c	/^db_nextrec(DBHANDLE h, char *key)$/;"	f
db_open	db/db.c	/^db_open(const char *pathname, int oflag, ...)$/;"	f
db_rewind	db/db.c	/^db_rewind(DBHANDLE h)$/;"	f
db_store	db/db.c	/^db_store(DBHANDLE h, const char *key, const char *data, int flag)$/;"	f
hashoff	db/db.c	/^  off_t  hashoff;  \/* offset in index file of hash table *\/$/;"	m	struct:__anon1	file:
idxbuf	db/db.c	/^  char  *idxbuf; \/* malloc'ed buffer for index record *\/$/;"	m	struct:__anon1	file:
idxfd	db/db.c	/^  int    idxfd;  \/* fd for index file *\/$/;"	m	struct:__anon1	file:
idxlen	db/db.c	/^  size_t idxlen; \/* length of index record *\/$/;"	m	struct:__anon1	file:
idxoff	db/db.c	/^  off_t  idxoff; \/* offset in index file of index record *\/$/;"	m	struct:__anon1	file:
name	db/db.c	/^  char  *name;   \/* name db was opened under *\/$/;"	m	struct:__anon1	file:
nhash	db/db.c	/^  DBHASH nhash;    \/* current hash table size *\/$/;"	m	struct:__anon1	file:
ptroff	db/db.c	/^  off_t  ptroff; \/* chain ptr offset pointing to this idx record *\/$/;"	m	struct:__anon1	file:
ptrval	db/db.c	/^  off_t  ptrval; \/* contents of chain ptr in index record *\/$/;"	m	struct:__anon1	file:
main	db/t4.c	/^main(void)$/;"	f
PLATFORM	environ/Makefile	/^PLATFORM=$(shell $(ROOT)\/systype.sh)$/;"	m
PROGS	environ/Makefile	/^PROGS = doatexit echoarg getrlimit hello1 testjmp$/;"	m
ROOT	environ/Makefile	/^ROOT=..$/;"	m
TOK_ADD	environ/cmd1.c	3;"	d	file:
cmd_add	environ/cmd1.c	/^cmd_add(void)$/;"	f
do_line	environ/cmd1.c	/^do_line(char *ptr)		\/* process one line of input *\/$/;"	f
get_token	environ/cmd1.c	/^get_token(void)$/;"	f
main	environ/cmd1.c	/^main(void)$/;"	f
tok_ptr	environ/cmd1.c	/^char	*tok_ptr;		\/* global pointer for get_token() *\/$/;"	v
TOK_ADD	environ/cmd2.c	4;"	d	file:
cmd_add	environ/cmd2.c	/^cmd_add(void)$/;"	f
jmpbuffer	environ/cmd2.c	/^jmp_buf	jmpbuffer;$/;"	v
main	environ/cmd2.c	/^main(void)$/;"	f
main	environ/doatexit.c	/^main(void)$/;"	f
my_exit1	environ/doatexit.c	/^my_exit1(void)$/;"	f	file:
my_exit2	environ/doatexit.c	/^my_exit2(void)$/;"	f	file:
main	environ/echoarg.c	/^main(int argc, char *argv[])$/;"	f
doit	environ/getrlimit.c	4;"	d	file:
main	environ/getrlimit.c	/^main(void)$/;"	f
pr_limits	environ/getrlimit.c	/^pr_limits(char *name, int resource)$/;"	f	file:
main	environ/hello1.c	/^main()$/;"	f
open_data	environ/opendata.c	/^open_data(void)$/;"	f
f1	environ/scope.c	/^f1(int val)$/;"	f
f1	environ/testjmp.c	/^f1(int i, int j, int k, int l)$/;"	f	file:
f2	environ/testjmp.c	/^f2(void)$/;"	f	file:
globval	environ/testjmp.c	/^static int		globval;$/;"	v	file:
jmpbuffer	environ/testjmp.c	/^static jmp_buf	jmpbuffer;$/;"	v	file:
main	environ/testjmp.c	/^main(void)$/;"	f
EXTRALIBS	exercises/Makefile	/^  EXTRALIBS=-pthread$/;"	m
FMEM	exercises/Makefile	/^  FMEM = fmemopen.o$/;"	m
FMEM	exercises/Makefile	/^  FMEM =$/;"	m
GETPW	exercises/Makefile	/^  GETPW = getpw44bsd$/;"	m
GETPW	exercises/Makefile	/^  GETPW = getpwsvr4$/;"	m
PLATFORM	exercises/Makefile	/^PLATFORM=$(shell $(ROOT)\/systype.sh)$/;"	m
PROGS	exercises/Makefile	/^PROGS =	bo fifo1 getlogin goodexit longpath pendlock prtime sizepipe vfork3 zombie$/;"	m
ROOT	exercises/Makefile	/^ROOT=..$/;"	m
clrasync	exercises/asyncsocket.c	/^clrasync(int sockfd)$/;"	f
setasync	exercises/asyncsocket.c	/^setasync(int sockfd)$/;"	f
main	exercises/bo.c	/^main(void)$/;"	f
FIFO	exercises/fifo1.c	4;"	d	file:
main	exercises/fifo1.c	/^main(void)$/;"	f
MIN	exercises/fmemopen.c	26;"	d	file:
MS_APPEND	exercises/fmemopen.c	21;"	d	file:
MS_MYBUF	exercises/fmemopen.c	23;"	d	file:
MS_READ	exercises/fmemopen.c	19;"	d	file:
MS_TRUNCATE	exercises/fmemopen.c	22;"	d	file:
MS_WRITE	exercises/fmemopen.c	20;"	d	file:
buf	exercises/fmemopen.c	/^	char	*buf;	\/* in-memory buffer *\/$/;"	m	struct:memstream	file:
curpos	exercises/fmemopen.c	/^	size_t	curpos;	\/* current position in buffer *\/$/;"	m	struct:memstream	file:
find_end	exercises/fmemopen.c	/^find_end(char *buf, size_t len)$/;"	f	file:
flags	exercises/fmemopen.c	/^	int		flags;	\/* see below *\/$/;"	m	struct:memstream	file:
fmemopen	exercises/fmemopen.c	/^fmemopen(void *__restrict buf, size_t size,$/;"	f
memstream	exercises/fmemopen.c	/^struct memstream$/;"	s	file:
mstream_close	exercises/fmemopen.c	/^mstream_close(void *cookie)$/;"	f	file:
mstream_read	exercises/fmemopen.c	/^mstream_read(void *cookie, char *buf, int len)$/;"	f	file:
mstream_seek	exercises/fmemopen.c	/^mstream_seek(void *cookie, fpos_t pos, int whence)$/;"	f	file:
mstream_write	exercises/fmemopen.c	/^mstream_write(void *cookie, const char *buf, int len)$/;"	f	file:
rsize	exercises/fmemopen.c	/^	size_t	rsize;	\/* real size of buffer *\/$/;"	m	struct:memstream	file:
type_to_flags	exercises/fmemopen.c	/^type_to_flags(const char *__restrict type)$/;"	f	file:
vsize	exercises/fmemopen.c	/^	size_t	vsize;	\/* virtual size of buffer *\/$/;"	m	struct:memstream	file:
main	exercises/getlogin.c	/^main(void)$/;"	f
main	exercises/getpw44bsd.c	/^main(void)		\/* FreeBSD\/Mac OS X version *\/$/;"	f
main	exercises/getpwsvr4.c	/^main(void)		\/* Linux\/Solaris version *\/$/;"	f
a	exercises/goodexit.c	/^	int a, b, c, d;$/;"	m	struct:foo	file:
b	exercises/goodexit.c	/^	int a, b, c, d;$/;"	m	struct:foo	file:
c	exercises/goodexit.c	/^	int a, b, c, d;$/;"	m	struct:foo	file:
d	exercises/goodexit.c	/^	int a, b, c, d;$/;"	m	struct:foo	file:
foo	exercises/goodexit.c	/^struct foo {$/;"	s	file:
main	exercises/goodexit.c	/^main(void)$/;"	f
printfoo	exercises/goodexit.c	/^printfoo(const char *s, const struct foo *fp)$/;"	f
thr_fn1	exercises/goodexit.c	/^thr_fn1(void *arg)$/;"	f
DEPTH	exercises/longpath.c	4;"	d	file:
MAXSZ	exercises/longpath.c	7;"	d	file:
NAME	exercises/longpath.c	6;"	d	file:
STARTDIR	exercises/longpath.c	5;"	d	file:
main	exercises/longpath.c	/^main(void)$/;"	f
OPEN_MAX_GUESS	exercises/openmax.c	5;"	d	file:
open_max	exercises/openmax.c	/^open_max(void)$/;"	f
main	exercises/pendlock.c	/^main(void)$/;"	f
sigint	exercises/pendlock.c	/^sigint(int signo)$/;"	f
KEY	exercises/pollmsg2.c	9;"	d	file:
MAXMSZ	exercises/pollmsg2.c	8;"	d	file:
NQ	exercises/pollmsg2.c	7;"	d	file:
fd	exercises/pollmsg2.c	/^	int				fd;$/;"	m	struct:threadinfo	file:
helper	exercises/pollmsg2.c	/^helper(void *arg)$/;"	f
len	exercises/pollmsg2.c	/^	int				len;$/;"	m	struct:threadinfo	file:
m	exercises/pollmsg2.c	/^	struct mymesg	m;$/;"	m	struct:threadinfo	typeref:struct:threadinfo::mymesg	file:
main	exercises/pollmsg2.c	/^main()$/;"	f
mtext	exercises/pollmsg2.c	/^	char		mtext[MAXMSZ+1];$/;"	m	struct:mymesg	file:
mtype	exercises/pollmsg2.c	/^	long		mtype;$/;"	m	struct:mymesg	file:
mutex	exercises/pollmsg2.c	/^	pthread_mutex_t	mutex;$/;"	m	struct:threadinfo	file:
mymesg	exercises/pollmsg2.c	/^struct mymesg {$/;"	s	file:
qid	exercises/pollmsg2.c	/^	int				qid;$/;"	m	struct:threadinfo	file:
ready	exercises/pollmsg2.c	/^	pthread_cond_t	ready;$/;"	m	struct:threadinfo	file:
threadinfo	exercises/pollmsg2.c	/^struct threadinfo {$/;"	s	file:
main	exercises/prtime.c	/^main(void)$/;"	f
main	exercises/sizepipe.c	/^main(void)$/;"	f
sleep	exercises/sleep.c	/^sleep(unsigned seconds)$/;"	f
sleep_us	exercises/sleepus_poll.c	/^sleep_us(unsigned int nusecs)$/;"	f
sleep_us	exercises/sleepus_select.c	/^sleep_us(unsigned int nusecs)$/;"	f
f1	exercises/vfork3.c	/^f1(void)$/;"	f	file:
f2	exercises/vfork3.c	/^f2(void)$/;"	f	file:
main	exercises/vfork3.c	/^main(void)$/;"	f
PSCMD	exercises/zombie.c	4;"	d	file:
PSCMD	exercises/zombie.c	6;"	d	file:
main	exercises/zombie.c	/^main(void)$/;"	f
MOREPROGS	filedir/Makefile	/^MOREPROGS = ftw8$/;"	m
PLATFORM	filedir/Makefile	/^PLATFORM=$(shell $(ROOT)\/systype.sh)$/;"	m
PROGS	filedir/Makefile	/^PROGS =	access cdpwd changemod devrdev filetype mycd umask unlink $(ZAP)$/;"	m
ROOT	filedir/Makefile	/^ROOT=..$/;"	m
ZAP	filedir/Makefile	/^	ZAP = zap$/;"	m
ZAP	filedir/Makefile	/^	ZAP =$/;"	m
main	filedir/access.c	/^main(int argc, char *argv[])$/;"	f
main	filedir/cdpwd.c	/^main(void)$/;"	f
main	filedir/changemod.c	/^main(void)$/;"	f
main	filedir/devrdev.c	/^main(int argc, char *argv[])$/;"	f
main	filedir/filetype.c	/^main(int argc, char *argv[])$/;"	f
FTW_D	filedir/ftw8.c	49;"	d	file:
FTW_DNR	filedir/ftw8.c	50;"	d	file:
FTW_F	filedir/ftw8.c	48;"	d	file:
FTW_NS	filedir/ftw8.c	51;"	d	file:
Myfunc	filedir/ftw8.c	/^typedef	int	Myfunc(const char *, const struct stat *, int);$/;"	t	file:
dopath	filedir/ftw8.c	/^dopath(Myfunc* func)$/;"	f	file:
fullpath	filedir/ftw8.c	/^static char	*fullpath;		\/* contains full pathname for every file *\/$/;"	v	file:
main	filedir/ftw8.c	/^main(int argc, char *argv[])$/;"	f
myftw	filedir/ftw8.c	/^myftw(char *pathname, Myfunc *func)$/;"	f	file:
myfunc	filedir/ftw8.c	/^myfunc(const char *pathname, const struct stat *statptr, int type)$/;"	f	file:
myfunc	filedir/ftw8.c	/^static Myfunc	myfunc;$/;"	v	file:
nblk	filedir/ftw8.c	/^static long	nreg, ndir, nblk, nchr, nfifo, nslink, nsock, ntot;$/;"	v	file:
nchr	filedir/ftw8.c	/^static long	nreg, ndir, nblk, nchr, nfifo, nslink, nsock, ntot;$/;"	v	file:
ndir	filedir/ftw8.c	/^static long	nreg, ndir, nblk, nchr, nfifo, nslink, nsock, ntot;$/;"	v	file:
nfifo	filedir/ftw8.c	/^static long	nreg, ndir, nblk, nchr, nfifo, nslink, nsock, ntot;$/;"	v	file:
nreg	filedir/ftw8.c	/^static long	nreg, ndir, nblk, nchr, nfifo, nslink, nsock, ntot;$/;"	v	file:
nslink	filedir/ftw8.c	/^static long	nreg, ndir, nblk, nchr, nfifo, nslink, nsock, ntot;$/;"	v	file:
nsock	filedir/ftw8.c	/^static long	nreg, ndir, nblk, nchr, nfifo, nslink, nsock, ntot;$/;"	v	file:
ntot	filedir/ftw8.c	/^static long	nreg, ndir, nblk, nchr, nfifo, nslink, nsock, ntot;$/;"	v	file:
pathlen	filedir/ftw8.c	/^static size_t pathlen;$/;"	v	file:
main	filedir/mycd.c	/^main(void)$/;"	f
RWRWRW	filedir/umask.c	4;"	d	file:
main	filedir/umask.c	/^main(void)$/;"	f
main	filedir/unlink.c	/^main(void)$/;"	f
main	filedir/zap.c	/^main(int argc, char *argv[])$/;"	f
PLATFORM	fileio/Makefile	/^PLATFORM=$(shell $(ROOT)\/systype.sh)$/;"	m
PROGS	fileio/Makefile	/^PROGS =	fileflags hole mycat seek$/;"	m
ROOT	fileio/Makefile	/^ROOT=..$/;"	m
main	fileio/fileflags.c	/^main(int argc, char *argv[])$/;"	f
buf1	fileio/hole.c	/^char	buf1[] = "abcdefghij";$/;"	v
buf2	fileio/hole.c	/^char	buf2[] = "ABCDEFGHIJ";$/;"	v
main	fileio/hole.c	/^main(void)$/;"	f
BUFFSIZE	fileio/mycat.c	3;"	d	file:
main	fileio/mycat.c	/^main(void)$/;"	f
main	fileio/seek.c	/^main(void)$/;"	f
set_fl	fileio/setfl.c	/^set_fl(int fd, int flags) \/* flags are file status flags to turn on *\/$/;"	f
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
DIR_MODE	include/apue.h	39;"	d
FILE_MODE	include/apue.h	34;"	d
MAXLINE	include/apue.h	29;"	d
Sigfunc	include/apue.h	/^typedef	void	Sigfunc(int);	\/* for signal handlers *\/$/;"	t
_APUE_H	include/apue.h	5;"	d
_POSIX_C_SOURCE	include/apue.h	7;"	d
_XOPEN_SOURCE	include/apue.h	10;"	d
_XOPEN_SOURCE	include/apue.h	12;"	d
is_read_lockable	include/apue.h	107;"	d
is_write_lockable	include/apue.h	109;"	d
max	include/apue.h	44;"	d
min	include/apue.h	43;"	d
read_lock	include/apue.h	94;"	d
readw_lock	include/apue.h	96;"	d
un_lock	include/apue.h	102;"	d
write_lock	include/apue.h	98;"	d
writew_lock	include/apue.h	100;"	d
PLATFORM	intro/Makefile	/^PLATFORM=$(shell $(ROOT)\/systype.sh)$/;"	m
PROGS	intro/Makefile	/^PROGS =	getcputc hello ls1 mycat shell1 shell2 testerror uidgid$/;"	m
ROOT	intro/Makefile	/^ROOT=..$/;"	m
main	intro/getcputc.c	/^main(void)$/;"	f
main	intro/hello.c	/^main(void)$/;"	f
main	intro/ls1.c	/^main(int argc, char* argv[]) {$/;"	f
BUFFSIZE	intro/mycat.c	3;"	d	file:
main	intro/mycat.c	/^main(void)$/;"	f
main	intro/shell1.c	/^main(void)$/;"	f
main	intro/shell2.c	/^main(void)$/;"	f
sig_int	intro/shell2.c	/^sig_int(int signo)$/;"	f
main	intro/testerror.c	/^main(int argc, char *argv[])$/;"	f
main	intro/uidgid.c	/^main(void)$/;"	f
PLATFORM	ipc1/Makefile	/^PLATFORM=$(shell $(ROOT)\/systype.sh)$/;"	m
PROGS	ipc1/Makefile	/^PROGS =	add2 add2stdio devzero myuclc pipe1 pipe2 pipe4 popen1 popen2 tshm$/;"	m
ROOT	ipc1/Makefile	/^ROOT=..$/;"	m
main	ipc1/add2.c	/^main(void)$/;"	f
main	ipc1/add2stdio.c	/^main(void)$/;"	f
NLOOPS	ipc1/devzero.c	5;"	d	file:
SIZE	ipc1/devzero.c	6;"	d	file:
main	ipc1/devzero.c	/^main(void)$/;"	f
update	ipc1/devzero.c	/^update(long *ptr)$/;"	f	file:
main	ipc1/myuclc.c	/^main(void)$/;"	f
main	ipc1/pipe1.c	/^main(void)$/;"	f
DEF_PAGER	ipc1/pipe2.c	4;"	d	file:
main	ipc1/pipe2.c	/^main(int argc, char *argv[])$/;"	f
main	ipc1/pipe4.c	/^main(void)$/;"	f
sig_pipe	ipc1/pipe4.c	/^sig_pipe(int signo)$/;"	f	file:
childpid	ipc1/popen.c	/^static pid_t	*childpid = NULL;$/;"	v	file:
maxfd	ipc1/popen.c	/^static int		maxfd;$/;"	v	file:
pclose	ipc1/popen.c	/^pclose(FILE *fp)$/;"	f
popen	ipc1/popen.c	/^popen(const char *cmdstring, const char *type)$/;"	f
main	ipc1/popen1.c	/^main(void)$/;"	f
PAGER	ipc1/popen2.c	4;"	d	file:
main	ipc1/popen2.c	/^main(int argc, char *argv[])$/;"	f
s_alloc	ipc1/slock.c	/^s_alloc()$/;"	f
s_free	ipc1/slock.c	/^s_free(struct slock *sp)$/;"	f
s_lock	ipc1/slock.c	/^s_lock(struct slock *sp)$/;"	f
s_trylock	ipc1/slock.c	/^s_trylock(struct slock *sp)$/;"	f
s_unlock	ipc1/slock.c	/^s_unlock(struct slock *sp)$/;"	f
name	ipc1/slock.h	/^	char name[_POSIX_NAME_MAX];$/;"	m	struct:slock
semp	ipc1/slock.h	/^	sem_t *semp;$/;"	m	struct:slock
slock	ipc1/slock.h	/^struct slock {$/;"	s
TELL_CHILD	ipc1/tellwait.c	/^TELL_CHILD(pid_t pid)$/;"	f
TELL_PARENT	ipc1/tellwait.c	/^TELL_PARENT(pid_t pid)$/;"	f
TELL_WAIT	ipc1/tellwait.c	/^TELL_WAIT(void)$/;"	f
WAIT_CHILD	ipc1/tellwait.c	/^WAIT_CHILD(void)$/;"	f
WAIT_PARENT	ipc1/tellwait.c	/^WAIT_PARENT(void)$/;"	f
pfd1	ipc1/tellwait.c	/^static int	pfd1[2], pfd2[2];$/;"	v	file:
pfd2	ipc1/tellwait.c	/^static int	pfd1[2], pfd2[2];$/;"	v	file:
ARRAY_SIZE	ipc1/tshm.c	4;"	d	file:
MALLOC_SIZE	ipc1/tshm.c	5;"	d	file:
SHM_MODE	ipc1/tshm.c	7;"	d	file:
SHM_SIZE	ipc1/tshm.c	6;"	d	file:
array	ipc1/tshm.c	/^char	array[ARRAY_SIZE];	\/* uninitialized data = bss *\/$/;"	v
main	ipc1/tshm.c	/^main(void)$/;"	f
EXTRALIBS	ipc2/Makefile	/^  EXTRALIBS=-lsocket -lnsl$/;"	m
EXTRALIBS	ipc2/Makefile	/^  EXTRALIBS=-pthread$/;"	m
FDPASS	ipc2/Makefile	/^	FDPASS = recvfd2.o sendfd2.o$/;"	m
FDPASS	ipc2/Makefile	/^FDPASS =$/;"	m
PLATFORM	ipc2/Makefile	/^PLATFORM=$(shell $(ROOT)\/systype.sh)$/;"	m
PROGS	ipc2/Makefile	/^PROGS =	bindunix pollmsg sendmsg$/;"	m
ROOT	ipc2/Makefile	/^ROOT=..$/;"	m
main	ipc2/bindunix.c	/^main(void)$/;"	f
EXTRALIBS	ipc2/open.fe/Makefile	/^  EXTRALIBS=-lsocket -lnsl$/;"	m
PLATFORM	ipc2/open.fe/Makefile	/^PLATFORM=$(shell $(ROOT)\/systype.sh)$/;"	m
PROGS	ipc2/open.fe/Makefile	/^PROGS =	openclient$/;"	m
ROOT	ipc2/open.fe/Makefile	/^ROOT=..\/..$/;"	m
BUFFSIZE	ipc2/open.fe/main.c	4;"	d	file:
main	ipc2/open.fe/main.c	/^main(int argc, char *argv[])$/;"	f
csopen	ipc2/open.fe/open.c	/^csopen(char *name, int oflag)$/;"	f
CL_OPEN	ipc2/open.fe/open.h	4;"	d
EXTRALIBS	ipc2/open/Makefile	/^  EXTRALIBS=-lsocket -lnsl$/;"	m
PLATFORM	ipc2/open/Makefile	/^PLATFORM=$(shell $(ROOT)\/systype.sh)$/;"	m
PROGS	ipc2/open/Makefile	/^PROGS =	openclient$/;"	m
ROOT	ipc2/open/Makefile	/^ROOT=..\/..$/;"	m
BUFFSIZE	ipc2/open/main.c	4;"	d	file:
main	ipc2/open/main.c	/^main(int argc, char *argv[])$/;"	f
csopen	ipc2/open/open.c	/^csopen(char *name, int oflag)$/;"	f
CL_OPEN	ipc2/open/open.h	4;"	d
CS_OPEN	ipc2/open/open.h	5;"	d
EXTRALIBS	ipc2/opend.fe/Makefile	/^  EXTRALIBS=-lsocket -lnsl$/;"	m
PLATFORM	ipc2/opend.fe/Makefile	/^PLATFORM=$(shell $(ROOT)\/systype.sh)$/;"	m
PROGS	ipc2/opend.fe/Makefile	/^PROGS =	opend$/;"	m
ROOT	ipc2/opend.fe/Makefile	/^ROOT=..\/..$/;"	m
cli_args	ipc2/opend.fe/cliargs.c	/^cli_args(int argc, char **argv)$/;"	f
errmsg	ipc2/opend.fe/main.c	/^char	 errmsg[MAXLINE];$/;"	v
main	ipc2/opend.fe/main.c	/^main(void)$/;"	f
oflag	ipc2/opend.fe/main.c	/^int		 oflag;$/;"	v
pathname	ipc2/opend.fe/main.c	/^char	*pathname;$/;"	v
CL_OPEN	ipc2/opend.fe/opend.h	4;"	d
handle_request	ipc2/opend.fe/request.c	/^handle_request(char *buf, int nread, int fd)$/;"	f
EXTRALIBS	ipc2/opend/Makefile	/^  EXTRALIBS=-lsocket -lnsl$/;"	m
PLATFORM	ipc2/opend/Makefile	/^PLATFORM=$(shell $(ROOT)\/systype.sh)$/;"	m
PROGS	ipc2/opend/Makefile	/^PROGS = opend.poll opend.select$/;"	m
ROOT	ipc2/opend/Makefile	/^ROOT=..\/..$/;"	m
cli_args	ipc2/opend/cliargs.c	/^cli_args(int argc, char **argv)$/;"	f
NALLOC	ipc2/opend/client.c	3;"	d	file:
client_add	ipc2/opend/client.c	/^client_add(int fd, uid_t uid)$/;"	f
client_alloc	ipc2/opend/client.c	/^client_alloc(void)		\/* alloc more entries in the client[] array *\/$/;"	f	file:
client_del	ipc2/opend/client.c	/^client_del(int fd)$/;"	f
NALLOC	ipc2/opend/loop.poll.c	4;"	d	file:
grow_pollfd	ipc2/opend/loop.poll.c	/^grow_pollfd(struct pollfd *pfd, int *maxfd)$/;"	f	file:
loop	ipc2/opend/loop.poll.c	/^loop(void)$/;"	f
loop	ipc2/opend/loop.select.c	/^loop(void)$/;"	f
client	ipc2/opend/main.c	/^Client	*client = NULL;$/;"	v
client_size	ipc2/opend/main.c	/^int		 debug, oflag, client_size, log_to_stderr;$/;"	v
debug	ipc2/opend/main.c	/^int		 debug, oflag, client_size, log_to_stderr;$/;"	v
errmsg	ipc2/opend/main.c	/^char	 errmsg[MAXLINE];$/;"	v
log_to_stderr	ipc2/opend/main.c	/^int		 debug, oflag, client_size, log_to_stderr;$/;"	v
main	ipc2/opend/main.c	/^main(int argc, char *argv[])$/;"	f
oflag	ipc2/opend/main.c	/^int		 debug, oflag, client_size, log_to_stderr;$/;"	v
pathname	ipc2/opend/main.c	/^char	*pathname;$/;"	v
CL_OPEN	ipc2/opend/opend.h	5;"	d
CS_OPEN	ipc2/opend/opend.h	4;"	d
Client	ipc2/opend/opend.h	/^} Client;$/;"	t	typeref:struct:__anon2
fd	ipc2/opend/opend.h	/^  int	fd;			\/* fd, or -1 if available *\/$/;"	m	struct:__anon2
uid	ipc2/opend/opend.h	/^  uid_t	uid;$/;"	m	struct:__anon2
handle_request	ipc2/opend/request.c	/^handle_request(char *buf, int nread, int clifd, uid_t uid)$/;"	f
KEY	ipc2/pollmsg.c	9;"	d	file:
MAXMSZ	ipc2/pollmsg.c	8;"	d	file:
NQ	ipc2/pollmsg.c	7;"	d	file:
fd	ipc2/pollmsg.c	/^	int fd;$/;"	m	struct:threadinfo	file:
helper	ipc2/pollmsg.c	/^helper(void *arg)$/;"	f
main	ipc2/pollmsg.c	/^main()$/;"	f
mtext	ipc2/pollmsg.c	/^	char mtext[MAXMSZ];$/;"	m	struct:mymesg	file:
mtype	ipc2/pollmsg.c	/^	long mtype;$/;"	m	struct:mymesg	file:
mymesg	ipc2/pollmsg.c	/^struct mymesg {$/;"	s	file:
qid	ipc2/pollmsg.c	/^	int qid;$/;"	m	struct:threadinfo	file:
threadinfo	ipc2/pollmsg.c	/^struct threadinfo {$/;"	s	file:
CONTROLLEN	ipc2/recvfd2.c	21;"	d	file:
CREDOPT	ipc2/recvfd2.c	12;"	d	file:
CREDSLEN	ipc2/recvfd2.c	20;"	d	file:
CREDSTRUCT	ipc2/recvfd2.c	10;"	d	file:
CREDSTRUCT	ipc2/recvfd2.c	6;"	d	file:
CR_UID	ipc2/recvfd2.c	11;"	d	file:
CR_UID	ipc2/recvfd2.c	7;"	d	file:
RIGHTSLEN	ipc2/recvfd2.c	19;"	d	file:
SCM_CREDTYPE	ipc2/recvfd2.c	13;"	d	file:
SCM_CREDTYPE	ipc2/recvfd2.c	8;"	d	file:
cmptr	ipc2/recvfd2.c	/^static struct cmsghdr	*cmptr = NULL;		\/* malloc'ed first time *\/$/;"	v	typeref:struct:cmsghdr	file:
recv_ufd	ipc2/recvfd2.c	/^recv_ufd(int fd, uid_t *uidptr,$/;"	f
CONTROLLEN	ipc2/sendfd2.c	17;"	d	file:
CREDSLEN	ipc2/sendfd2.c	16;"	d	file:
CREDSTRUCT	ipc2/sendfd2.c	5;"	d	file:
CREDSTRUCT	ipc2/sendfd2.c	8;"	d	file:
RIGHTSLEN	ipc2/sendfd2.c	15;"	d	file:
SCM_CREDTYPE	ipc2/sendfd2.c	6;"	d	file:
SCM_CREDTYPE	ipc2/sendfd2.c	9;"	d	file:
cmptr	ipc2/sendfd2.c	/^static struct cmsghdr	*cmptr = NULL;	\/* malloc'ed first time *\/$/;"	v	typeref:struct:cmsghdr	file:
send_fd	ipc2/sendfd2.c	/^send_fd(int fd, int fd_to_send)$/;"	f
MAXMSZ	ipc2/sendmsg.c	4;"	d	file:
main	ipc2/sendmsg.c	/^main(int argc, char *argv[])$/;"	f
mtext	ipc2/sendmsg.c	/^	char mtext[MAXMSZ];$/;"	m	struct:mymesg	file:
mtype	ipc2/sendmsg.c	/^	long mtype;$/;"	m	struct:mymesg	file:
mymesg	ipc2/sendmsg.c	/^struct mymesg {$/;"	s	file:
LIBMISC	lib/Makefile	/^LIBMISC	= libapue.a$/;"	m
OBJS	lib/Makefile	/^OBJS   = bufargs.o cliconn.o clrfl.o \\$/;"	m
PLATFORM	lib/Makefile	/^PLATFORM=$(shell $(ROOT)\/systype.sh)$/;"	m
ROOT	lib/Makefile	/^ROOT=..$/;"	m
CONTROLLEN	lib/Orecvfd.c	5;"	d	file:
cmptr	lib/Orecvfd.c	/^static struct cmsghdr	*cmptr = NULL;		\/* malloc'ed first time *\/$/;"	v	typeref:struct:cmsghdr	file:
recv_fd	lib/Orecvfd.c	/^recv_fd(int fd, ssize_t (*userfunc)(int, const void *, size_t))$/;"	f
MAXARGC	lib/bufargs.c	3;"	d	file:
WHITE	lib/bufargs.c	4;"	d	file:
buf_args	lib/bufargs.c	/^buf_args(char *buf, int (*optfunc)(int, char **))$/;"	f
CLI_PATH	lib/cliconn.c	6;"	d	file:
CLI_PERM	lib/cliconn.c	7;"	d	file:
cli_conn	lib/cliconn.c	/^cli_conn(const char *name)$/;"	f
clr_fl	lib/clrfl.c	/^clr_fl(int fd, int flags)$/;"	f
daemonize	lib/daemonize.c	/^daemonize(const char *cmd)$/;"	f
err_cont	lib/error.c	/^err_cont(int error, const char *fmt, ...)$/;"	f
err_doit	lib/error.c	/^err_doit(int errnoflag, int error, const char *fmt, va_list ap)$/;"	f	file:
err_dump	lib/error.c	/^err_dump(const char *fmt, ...)$/;"	f
err_exit	lib/error.c	/^err_exit(int error, const char *fmt, ...)$/;"	f
err_msg	lib/error.c	/^err_msg(const char *fmt, ...)$/;"	f
err_quit	lib/error.c	/^err_quit(const char *fmt, ...)$/;"	f
err_ret	lib/error.c	/^err_ret(const char *fmt, ...)$/;"	f
err_sys	lib/error.c	/^err_sys(const char *fmt, ...)$/;"	f
log_doit	lib/errorlog.c	/^log_doit(int errnoflag, int error, int priority, const char *fmt,$/;"	f	file:
log_exit	lib/errorlog.c	/^log_exit(int error, const char *fmt, ...)$/;"	f
log_msg	lib/errorlog.c	/^log_msg(const char *fmt, ...)$/;"	f
log_open	lib/errorlog.c	/^log_open(const char *ident, int option, int facility)$/;"	f
log_quit	lib/errorlog.c	/^log_quit(const char *fmt, ...)$/;"	f
log_ret	lib/errorlog.c	/^log_ret(const char *fmt, ...)$/;"	f
log_sys	lib/errorlog.c	/^log_sys(const char *fmt, ...)$/;"	f
lock_reg	lib/lockreg.c	/^lock_reg(int fd, int cmd, int type, off_t offset, int whence, off_t len)$/;"	f
lock_test	lib/locktest.c	/^lock_test(int fd, int type, off_t offset, int whence, off_t len)$/;"	f
ns_pipe	lib/nspipe.c	/^ns_pipe(const char *name, int fd[2])$/;"	f
OPEN_MAX_GUESS	lib/openmax.c	14;"	d	file:
open_max	lib/openmax.c	/^open_max(void)$/;"	f
openmax	lib/openmax.c	/^static long	openmax = 0;$/;"	v	file:
openmax	lib/openmax.c	/^static long	openmax = OPEN_MAX;$/;"	v	file:
PATH_MAX_GUESS	lib/pathalloc.c	15;"	d	file:
path_alloc	lib/pathalloc.c	/^path_alloc(size_t *sizep) \/* also return allocated size, if nonnull *\/$/;"	f
pathmax	lib/pathalloc.c	/^static long	pathmax = 0;$/;"	v	file:
pathmax	lib/pathalloc.c	/^static long	pathmax = PATH_MAX;$/;"	v	file:
posix_version	lib/pathalloc.c	/^static long	posix_version = 0;$/;"	v	file:
xsi_version	lib/pathalloc.c	/^static long	xsi_version = 0;$/;"	v	file:
childpid	lib/popen.c	/^static pid_t	*childpid = NULL;$/;"	v	file:
maxfd	lib/popen.c	/^static int		maxfd;$/;"	v	file:
pclose	lib/popen.c	/^pclose(FILE *fp)$/;"	f
popen	lib/popen.c	/^popen(const char *cmdstring, const char *type)$/;"	f
pr_exit	lib/prexit.c	/^pr_exit(int status)$/;"	f
pr_mask	lib/prmask.c	/^pr_mask(const char *str)$/;"	f
pty_fork	lib/ptyfork.c	/^pty_fork(int *ptrfdm, char *slave_name, int slave_namesz,$/;"	f
ptym_open	lib/ptyopen.c	/^ptym_open(char *pts_name, int pts_namesz)$/;"	f
ptys_open	lib/ptyopen.c	/^ptys_open(char *pts_name)$/;"	f
readn	lib/readn.c	/^readn(int fd, void *ptr, size_t n)$/;"	f
CONTROLLEN	lib/recvfd.c	5;"	d	file:
RELOP	lib/recvfd.c	10;"	d	file:
RELOP	lib/recvfd.c	8;"	d	file:
cmptr	lib/recvfd.c	/^static struct cmsghdr	*cmptr = NULL;		\/* malloc'ed first time *\/$/;"	v	typeref:struct:cmsghdr	file:
recv_fd	lib/recvfd.c	/^recv_fd(int fd, ssize_t (*userfunc)(int, const void *, size_t))$/;"	f
BIGCOUNT	lib/semaph.c	43;"	d	file:
op_close	lib/semaph.c	/^static struct sembuf	op_close[3] = {$/;"	v	typeref:struct:sembuf	file:
op_endcreate	lib/semaph.c	/^static struct sembuf	op_endcreate[2] = {$/;"	v	typeref:struct:sembuf	file:
op_lock	lib/semaph.c	/^static struct sembuf	op_lock[2] = {$/;"	v	typeref:struct:sembuf	file:
op_op	lib/semaph.c	/^static struct sembuf	op_op[1] = {$/;"	v	typeref:struct:sembuf	file:
op_open	lib/semaph.c	/^static struct sembuf	op_open[1] = {$/;"	v	typeref:struct:sembuf	file:
op_unlock	lib/semaph.c	/^static struct sembuf	op_unlock[1] = {$/;"	v	typeref:struct:sembuf	file:
sem_close	lib/semaph.c	/^sem_close(int id)$/;"	f
sem_create	lib/semaph.c	/^sem_create(key_t key, int initval)$/;"	f
sem_op	lib/semaph.c	/^sem_op(int id, int value)$/;"	f
sem_open	lib/semaph.c	/^sem_open(key_t key)$/;"	f
sem_rm	lib/semaph.c	/^sem_rm(int id)$/;"	f
sem_signal	lib/semaph.c	/^sem_signal(int id)$/;"	f
sem_wait	lib/semaph.c	/^sem_wait(int id)$/;"	f
send_err	lib/senderr.c	/^send_err(int fd, int errcode, const char *msg)$/;"	f
CONTROLLEN	lib/sendfd.c	5;"	d	file:
cmptr	lib/sendfd.c	/^static struct cmsghdr	*cmptr = NULL;	\/* malloc'ed first time *\/$/;"	v	typeref:struct:cmsghdr	file:
send_fd	lib/sendfd.c	/^send_fd(int fd, int fd_to_send)$/;"	f
STALE	lib/servaccept.c	7;"	d	file:
serv_accept	lib/servaccept.c	/^serv_accept(int listenfd, uid_t *uidptr)$/;"	f
QLEN	lib/servlisten.c	6;"	d	file:
serv_listen	lib/servlisten.c	/^serv_listen(const char *name)$/;"	f
set_cloexec	lib/setfd.c	/^set_cloexec(int fd)$/;"	f
set_fl	lib/setfl.c	/^set_fl(int fd, int flags) \/* flags are file status flags to turn on *\/$/;"	f
signal	lib/signal.c	/^signal(int signo, Sigfunc *func)$/;"	f
signal_intr	lib/signalintr.c	/^signal_intr(int signo, Sigfunc *func)$/;"	f
sig_alrm	lib/sleep.c	/^sig_alrm(int signo)$/;"	f	file:
sleep	lib/sleep.c	/^sleep(unsigned int seconds)$/;"	f
sleep_us	lib/sleepus.c	/^sleep_us(unsigned int nusecs)$/;"	f
fd_pipe	lib/spipe.c	/^fd_pipe(int fd[2])$/;"	f
strerror	lib/strerror.c	/^strerror(int error)$/;"	f
TELL_CHILD	lib/tellwait.c	/^TELL_CHILD(pid_t pid)$/;"	f
TELL_PARENT	lib/tellwait.c	/^TELL_PARENT(pid_t pid)$/;"	f
TELL_WAIT	lib/tellwait.c	/^TELL_WAIT(void)$/;"	f
WAIT_CHILD	lib/tellwait.c	/^WAIT_CHILD(void)$/;"	f
WAIT_PARENT	lib/tellwait.c	/^WAIT_PARENT(void)$/;"	f
newmask	lib/tellwait.c	/^static sigset_t newmask, oldmask, zeromask;$/;"	v	file:
oldmask	lib/tellwait.c	/^static sigset_t newmask, oldmask, zeromask;$/;"	v	file:
sig_usr	lib/tellwait.c	/^sig_usr(int signo)	\/* one signal handler for SIGUSR1 and SIGUSR2 *\/$/;"	f	file:
sigflag	lib/tellwait.c	/^static volatile sig_atomic_t sigflag; \/* set nonzero by sig handler *\/$/;"	v	file:
zeromask	lib/tellwait.c	/^static sigset_t newmask, oldmask, zeromask;$/;"	v	file:
CBREAK	lib/ttymodes.c	/^static enum { RESET, RAW, CBREAK }	ttystate = RESET;$/;"	e	enum:__anon3	file:
RAW	lib/ttymodes.c	/^static enum { RESET, RAW, CBREAK }	ttystate = RESET;$/;"	e	enum:__anon3	file:
RESET	lib/ttymodes.c	/^static enum { RESET, RAW, CBREAK }	ttystate = RESET;$/;"	e	enum:__anon3	file:
save_termios	lib/ttymodes.c	/^static struct termios		save_termios;$/;"	v	typeref:struct:termios	file:
tty_atexit	lib/ttymodes.c	/^tty_atexit(void)		\/* can be set up by atexit(tty_atexit) *\/$/;"	f
tty_cbreak	lib/ttymodes.c	/^tty_cbreak(int fd)	\/* put terminal into a cbreak mode *\/$/;"	f
tty_raw	lib/ttymodes.c	/^tty_raw(int fd)		\/* put terminal into a raw mode *\/$/;"	f
tty_reset	lib/ttymodes.c	/^tty_reset(int fd)		\/* restore terminal's mode *\/$/;"	f
tty_termios	lib/ttymodes.c	/^tty_termios(void)		\/* let caller see original tty state *\/$/;"	f
ttysavefd	lib/ttymodes.c	/^static int					ttysavefd = -1;$/;"	v	file:
ttystate	lib/ttymodes.c	/^static enum { RESET, RAW, CBREAK }	ttystate = RESET;$/;"	v	typeref:enum:__anon3	file:
writen	lib/writen.c	/^writen(int fd, const void *ptr, size_t n)$/;"	f
EXTRA	printer/Makefile	/^EXTRA=$/;"	m
EXTRALIBS	printer/Makefile	/^  EXTRALIBS=-lsocket -lnsl -lrt -lpthread$/;"	m
EXTRALIBS	printer/Makefile	/^  EXTRALIBS=-pthread$/;"	m
HDRS	printer/Makefile	/^HDRS = print.h ipp.h$/;"	m
PLATFORM	printer/Makefile	/^PLATFORM=$(shell $(ROOT)\/systype.sh)$/;"	m
PROGS	printer/Makefile	/^PROGS = print printd$/;"	m
ROOT	printer/Makefile	/^ROOT=..$/;"	m
OP_CANCEL_JOB	printer/ipp.h	65;"	d
OP_CREATE_JOB	printer/ipp.h	62;"	d
OP_GET_JOBS	printer/ipp.h	67;"	d
OP_GET_JOB_ATTR	printer/ipp.h	66;"	d
OP_GET_PRINTER_ATTR	printer/ipp.h	68;"	d
OP_HOLD_JOB	printer/ipp.h	69;"	d
OP_PAUSE_PRINTER	printer/ipp.h	72;"	d
OP_PRINT_JOB	printer/ipp.h	59;"	d
OP_PRINT_URI	printer/ipp.h	60;"	d
OP_PURGE_JOBS	printer/ipp.h	74;"	d
OP_RELEASE_JOB	printer/ipp.h	70;"	d
OP_RESTART_JOB	printer/ipp.h	71;"	d
OP_RESUME_PRINTER	printer/ipp.h	73;"	d
OP_SEND_DOC	printer/ipp.h	63;"	d
OP_SEND_URI	printer/ipp.h	64;"	d
OP_VALIDATE_JOB	printer/ipp.h	61;"	d
STATCLASS_CLIERR	printer/ipp.h	15;"	d
STATCLASS_INFO	printer/ipp.h	13;"	d
STATCLASS_OK	printer/ipp.h	12;"	d
STATCLASS_REDIR	printer/ipp.h	14;"	d
STATCLASS_SRVERR	printer/ipp.h	16;"	d
STAT_CLI_ACCERR	printer/ipp.h	43;"	d
STAT_CLI_ATTRCON	printer/ipp.h	39;"	d
STAT_CLI_BADFMT	printer/ipp.h	35;"	d
STAT_CLI_BADREQ	printer/ipp.h	25;"	d
STAT_CLI_COMPERR	printer/ipp.h	41;"	d
STAT_CLI_FMTERR	printer/ipp.h	42;"	d
STAT_CLI_FORBID	printer/ipp.h	26;"	d
STAT_CLI_NOAUTH	printer/ipp.h	27;"	d
STAT_CLI_NOCHAR	printer/ipp.h	38;"	d
STAT_CLI_NOCOMP	printer/ipp.h	40;"	d
STAT_CLI_NOPERM	printer/ipp.h	28;"	d
STAT_CLI_NOSCHM	printer/ipp.h	37;"	d
STAT_CLI_NOTFND	printer/ipp.h	31;"	d
STAT_CLI_NOTPOS	printer/ipp.h	29;"	d
STAT_CLI_NOTSUP	printer/ipp.h	36;"	d
STAT_CLI_OBJGONE	printer/ipp.h	32;"	d
STAT_CLI_TIMOUT	printer/ipp.h	30;"	d
STAT_CLI_TOOBIG	printer/ipp.h	33;"	d
STAT_CLI_TOOLNG	printer/ipp.h	34;"	d
STAT_OK	printer/ipp.h	21;"	d
STAT_OK_ATTRCON	printer/ipp.h	23;"	d
STAT_OK_ATTRIGN	printer/ipp.h	22;"	d
STAT_SRV_BADVER	printer/ipp.h	48;"	d
STAT_SRV_CANCEL	printer/ipp.h	53;"	d
STAT_SRV_DEVERR	printer/ipp.h	49;"	d
STAT_SRV_INTERN	printer/ipp.h	45;"	d
STAT_SRV_NOMULTI	printer/ipp.h	54;"	d
STAT_SRV_NOTSUP	printer/ipp.h	46;"	d
STAT_SRV_REJECT	printer/ipp.h	51;"	d
STAT_SRV_TMPERR	printer/ipp.h	50;"	d
STAT_SRV_TOOBUSY	printer/ipp.h	52;"	d
STAT_SRV_UNAVAIL	printer/ipp.h	47;"	d
TAG_BOOLEAN	printer/ipp.h	92;"	d
TAG_CHARSET	printer/ipp.h	105;"	d
TAG_DATETIME	printer/ipp.h	95;"	d
TAG_END_OF_ATTR	printer/ipp.h	81;"	d
TAG_ENUM	printer/ipp.h	93;"	d
TAG_INTEGER	printer/ipp.h	91;"	d
TAG_INTRANGE	printer/ipp.h	97;"	d
TAG_JOB_ATTR	printer/ipp.h	80;"	d
TAG_KEYWORD	printer/ipp.h	102;"	d
TAG_MIMETYPE	printer/ipp.h	107;"	d
TAG_NAMEWLANG	printer/ipp.h	99;"	d
TAG_NAMEWOLANG	printer/ipp.h	101;"	d
TAG_NATULANG	printer/ipp.h	106;"	d
TAG_NONE	printer/ipp.h	90;"	d
TAG_OCTSTR	printer/ipp.h	94;"	d
TAG_OPERATION_ATTR	printer/ipp.h	79;"	d
TAG_PRINTER_ATTR	printer/ipp.h	82;"	d
TAG_RESOLUTION	printer/ipp.h	96;"	d
TAG_TEXTWLANG	printer/ipp.h	98;"	d
TAG_TEXTWOLANG	printer/ipp.h	100;"	d
TAG_UNKNOWN	printer/ipp.h	89;"	d
TAG_UNSUPPORTED	printer/ipp.h	88;"	d
TAG_UNSUPP_ATTR	printer/ipp.h	83;"	d
TAG_URI	printer/ipp.h	103;"	d
TAG_URISCHEME	printer/ipp.h	104;"	d
_IPP_H	printer/ipp.h	2;"	d
attr_group	printer/ipp.h	/^	char    attr_group[1];	\/* start of optional attributes group *\/$/;"	m	struct:ipp_hdr
ipp_hdr	printer/ipp.h	/^struct ipp_hdr {$/;"	s
major_version	printer/ipp.h	/^	int8_t  major_version;	\/* always 1 *\/$/;"	m	struct:ipp_hdr
minor_version	printer/ipp.h	/^	int8_t  minor_version;	\/* always 1 *\/$/;"	m	struct:ipp_hdr
op	printer/ipp.h	/^		int16_t op;	\/* operation ID *\/$/;"	m	union:ipp_hdr::__anon4
operation	printer/ipp.h	121;"	d
request_id	printer/ipp.h	/^	int32_t request_id;		\/* request ID *\/$/;"	m	struct:ipp_hdr
st	printer/ipp.h	/^		int16_t st;	\/* status *\/$/;"	m	union:ipp_hdr::__anon4
status	printer/ipp.h	122;"	d
u	printer/ipp.h	/^	} u;$/;"	m	struct:ipp_hdr	typeref:union:ipp_hdr::__anon4
log_to_stderr	printer/print.c	/^int log_to_stderr = 1;$/;"	v
main	printer/print.c	/^main(int argc, char *argv[])$/;"	f
submit_file	printer/print.c	/^submit_file(int fd, int sockfd, const char *fname, size_t nbytes,$/;"	f
CONFIG_FILE	printer/print.h	12;"	d
DATADIR	printer/print.h	15;"	d
ETIME	printer/print.h	45;"	d
FILENMSZ	printer/print.h	26;"	d
FILEPERM	printer/print.h	27;"	d
HBUFSZ	printer/print.h	41;"	d
HOST_NAME_MAX	printer/print.h	34;"	d
IBUFSZ	printer/print.h	40;"	d
IOBUFSZ	printer/print.h	42;"	d
IPP_PORT	printer/print.h	37;"	d
JOBFILE	printer/print.h	14;"	d
JOBNM_MAX	printer/print.h	30;"	d
LPNAME	printer/print.h	19;"	d
LPNAME	printer/print.h	21;"	d
LPNAME	printer/print.h	23;"	d
MSGLEN_MAX	printer/print.h	31;"	d
PR_TEXT	printer/print.h	72;"	d
QLEN	printer/print.h	38;"	d
REQDIR	printer/print.h	16;"	d
SPOOLDIR	printer/print.h	13;"	d
USERNM_MAX	printer/print.h	29;"	d
_PRINT_H	printer/print.h	2;"	d
flags	printer/print.h	/^	uint32_t flags;				\/* see below *\/$/;"	m	struct:printreq
jobid	printer/print.h	/^	uint32_t jobid;				\/* job ID *\/$/;"	m	struct:printresp
jobnm	printer/print.h	/^	char jobnm[JOBNM_MAX];		\/* job's name *\/$/;"	m	struct:printreq
msg	printer/print.h	/^	char msg[MSGLEN_MAX];		\/* error message *\/$/;"	m	struct:printresp
printreq	printer/print.h	/^struct printreq {$/;"	s
printresp	printer/print.h	/^struct printresp {$/;"	s
retcode	printer/print.h	/^	uint32_t retcode;			\/* 0=success, !0=error code *\/$/;"	m	struct:printresp
size	printer/print.h	/^	uint32_t size;				\/* size in bytes *\/$/;"	m	struct:printreq
usernm	printer/print.h	/^	char usernm[USERNM_MAX];	\/* user's name *\/$/;"	m	struct:printreq
HTTP_INFO	printer/printd.c	20;"	d	file:
HTTP_SUCCESS	printer/printd.c	21;"	d	file:
add_job	printer/printd.c	/^add_job(struct printreq *reqp, int32_t jobid)$/;"	f
add_option	printer/printd.c	/^add_option(char *cp, int tag, char *optname, char *optval)$/;"	f
add_worker	printer/printd.c	/^add_worker(pthread_t tid, int sockfd)$/;"	f
build_qonstart	printer/printd.c	/^build_qonstart(void)$/;"	f
client_cleanup	printer/printd.c	/^client_cleanup(void *arg)$/;"	f
client_thread	printer/printd.c	/^client_thread(void *arg)$/;"	f
configlock	printer/printd.c	/^pthread_mutex_t		configlock = PTHREAD_MUTEX_INITIALIZER;$/;"	v
get_newjobno	printer/printd.c	/^get_newjobno(void)$/;"	f
init_printer	printer/printd.c	/^init_printer(void)$/;"	f
init_request	printer/printd.c	/^init_request(void)$/;"	f
job	printer/printd.c	/^struct job {$/;"	s	file:
jobfd	printer/printd.c	/^int					jobfd;$/;"	v
jobhead	printer/printd.c	/^struct job				*jobhead, *jobtail;$/;"	v	typeref:struct:job
jobid	printer/printd.c	/^	int32_t          jobid;		\/* job ID *\/$/;"	m	struct:job	file:
joblock	printer/printd.c	/^pthread_mutex_t		joblock = PTHREAD_MUTEX_INITIALIZER;$/;"	v
jobtail	printer/printd.c	/^struct job				*jobhead, *jobtail;$/;"	v	typeref:struct:
jobwait	printer/printd.c	/^pthread_cond_t			jobwait = PTHREAD_COND_INITIALIZER;$/;"	v
kill_workers	printer/printd.c	/^kill_workers(void)$/;"	f
log_to_stderr	printer/printd.c	/^int					log_to_stderr = 0;$/;"	v
main	printer/printd.c	/^main(int argc, char *argv[])$/;"	f
mask	printer/printd.c	/^sigset_t				mask;$/;"	v
next	printer/printd.c	/^	struct job      *next;		\/* next in list *\/$/;"	m	struct:job	typeref:struct:job::job	file:
next	printer/printd.c	/^	struct worker_thread  *next;	\/* next in list *\/$/;"	m	struct:worker_thread	typeref:struct:worker_thread::worker_thread	file:
nextjob	printer/printd.c	/^int32_t				nextjob;$/;"	v
prev	printer/printd.c	/^	struct job      *prev;		\/* previous in list *\/$/;"	m	struct:job	typeref:struct:job::job	file:
prev	printer/printd.c	/^	struct worker_thread  *prev;	\/* previous in list *\/$/;"	m	struct:worker_thread	typeref:struct:worker_thread::worker_thread	file:
printer	printer/printd.c	/^struct addrinfo		*printer;$/;"	v	typeref:struct:addrinfo
printer_name	printer/printd.c	/^char					*printer_name;$/;"	v
printer_status	printer/printd.c	/^printer_status(int sfd, struct job *jp)$/;"	f
printer_thread	printer/printd.c	/^printer_thread(void *arg)$/;"	f
readmore	printer/printd.c	/^readmore(int sockfd, char **bpp, int off, int *bszp)$/;"	f
remove_job	printer/printd.c	/^remove_job(struct job *target)$/;"	f
replace_job	printer/printd.c	/^replace_job(struct job *jp)$/;"	f
req	printer/printd.c	/^	struct printreq  req;		\/* copy of print request *\/$/;"	m	struct:job	typeref:struct:job::printreq	file:
reread	printer/printd.c	/^int					reread;$/;"	v
signal_thread	printer/printd.c	/^signal_thread(void *arg)$/;"	f
sockfd	printer/printd.c	/^	int                    sockfd;	\/* socket *\/$/;"	m	struct:worker_thread	file:
tid	printer/printd.c	/^	pthread_t              tid;		\/* thread ID *\/$/;"	m	struct:worker_thread	file:
update_jobno	printer/printd.c	/^update_jobno(void)$/;"	f
worker_thread	printer/printd.c	/^struct worker_thread {$/;"	s	file:
workerlock	printer/printd.c	/^pthread_mutex_t		workerlock = PTHREAD_MUTEX_INITIALIZER;$/;"	v
workers	printer/printd.c	/^struct worker_thread	*workers;$/;"	v	typeref:struct:worker_thread
MAXCFGLINE	printer/util.c	6;"	d	file:
MAXFMTLEN	printer/util.c	8;"	d	file:
MAXKWLEN	printer/util.c	7;"	d	file:
get_printaddr	printer/util.c	/^get_printaddr(void)$/;"	f
get_printserver	printer/util.c	/^get_printserver(void)$/;"	f
getaddrlist	printer/util.c	/^getaddrlist(const char *host, const char *service,$/;"	f
scan_configfile	printer/util.c	/^scan_configfile(char *keyword)$/;"	f	file:
tread	printer/util.c	/^tread(int fd, void *buf, size_t nbytes, unsigned int timout)$/;"	f
treadn	printer/util.c	/^treadn(int fd, void *buf, size_t nbytes, unsigned int timout)$/;"	f
ACCT	proc/Makefile	/^  ACCT=pracct$/;"	m
ACCT	proc/Makefile	/^ACCT=$/;"	m
ACCTFLAGS	proc/Makefile	/^  ACCTFLAGS = -DHAS_AC_STAT$/;"	m
ACCTFLAGS	proc/Makefile	/^  ACCTFLAGS = -DHAS_AXSIG -DHAS_ACORE$/;"	m
ACCTFLAGS	proc/Makefile	/^ACCTFLAGS=$/;"	m
MOREPROGS	proc/Makefile	/^MOREPROGS = systest1 systest3$/;"	m
PLATFORM	proc/Makefile	/^PLATFORM=$(shell $(ROOT)\/systype.sh)$/;"	m
PROGS	proc/Makefile	/^PROGS =	echoall exec1 exec2 fork1 fork2 nice pruids tellwait1 tellwait2 test1 times1 vfork1 wait1$/;"	m
ROOT	proc/Makefile	/^ROOT=..$/;"	m
main	proc/echoall.c	/^main(int argc, char *argv[])$/;"	f
env_init	proc/exec1.c	/^char	*env_init[] = { "USER=unknown", "PATH=\/tmp", NULL };$/;"	v
main	proc/exec1.c	/^main(void)$/;"	f
main	proc/exec2.c	/^main(void)$/;"	f
buf	proc/fork1.c	/^char	buf[] = "a write to stdout\\n";$/;"	v
globvar	proc/fork1.c	/^int		globvar = 6;		\/* external variable in initialized data *\/$/;"	v
main	proc/fork1.c	/^main(void)$/;"	f
main	proc/fork2.c	/^main(void)$/;"	f
checktime	proc/nice.c	/^checktime(char *str)$/;"	f
count	proc/nice.c	/^unsigned long long count;$/;"	v
end	proc/nice.c	/^struct timeval end;$/;"	v	typeref:struct:timeval
main	proc/nice.c	/^main(int argc, char *argv[])$/;"	f
ACORE	proc/pracct.c	18;"	d	file:
AXSIG	proc/pracct.c	21;"	d	file:
FMT	proc/pracct.c	11;"	d	file:
FMT	proc/pracct.c	7;"	d	file:
FMT	proc/pracct.c	9;"	d	file:
ac_flag	proc/pracct.c	6;"	d	file:
acct	proc/pracct.c	14;"	d	file:
acct	proc/pracct.c	5;"	d	file:
compt2ulong	proc/pracct.c	/^compt2ulong(comp_t comptime)	\/* convert comp_t to unsigned long *\/$/;"	f	file:
main	proc/pracct.c	/^main(int argc, char *argv[])$/;"	f
main	proc/pruids.c	/^main(void)$/;"	f
system	proc/system.c	/^system(const char *cmdstring)	\/* version without signal handling *\/$/;"	f
main	proc/systest1.c	/^main(void)$/;"	f
main	proc/systest3.c	/^main(int argc, char *argv[])$/;"	f
charatatime	proc/tellwait1.c	/^charatatime(char *str)$/;"	f	file:
main	proc/tellwait1.c	/^main(void)$/;"	f
charatatime	proc/tellwait2.c	/^charatatime(char *str)$/;"	f	file:
main	proc/tellwait2.c	/^main(void)$/;"	f
main	proc/test1.c	/^main(void)$/;"	f
do_cmd	proc/times1.c	/^do_cmd(char *cmd)		\/* execute and time the "cmd" *\/$/;"	f	file:
main	proc/times1.c	/^main(int argc, char *argv[])$/;"	f
pr_times	proc/times1.c	/^pr_times(clock_t real, struct tms *tmsstart, struct tms *tmsend)$/;"	f	file:
globvar	proc/vfork1.c	/^int		globvar = 6;		\/* external variable in initialized data *\/$/;"	v
main	proc/vfork1.c	/^main(void)$/;"	f
main	proc/wait1.c	/^main(void)$/;"	f
EXTRALIBS	pty/Makefile	/^  EXTRALIBS=-lsocket -lnsl$/;"	m
PLATFORM	pty/Makefile	/^PLATFORM=$(shell $(ROOT)\/systype.sh)$/;"	m
PROGS	pty/Makefile	/^PROGS =	pty$/;"	m
ROOT	pty/Makefile	/^ROOT=..$/;"	m
do_driver	pty/driver.c	/^do_driver(char *driver)$/;"	f
BUFFSIZE	pty/loop.c	3;"	d	file:
loop	pty/loop.c	/^loop(int ptym, int ignoreeof)$/;"	f
sig_term	pty/loop.c	/^sig_term(int signo)$/;"	f	file:
sigcaught	pty/loop.c	/^static volatile sig_atomic_t	sigcaught;	\/* set by signal handler *\/$/;"	v	file:
OPTSTR	pty/main.c	5;"	d	file:
OPTSTR	pty/main.c	7;"	d	file:
main	pty/main.c	/^main(int argc, char *argv[])$/;"	f
set_noecho	pty/main.c	/^set_noecho(int fd)		\/* turn off echo (for slave pty) *\/$/;"	f	file:
PLATFORM	relation/Makefile	/^PLATFORM=$(shell $(ROOT)\/systype.sh)$/;"	m
PROGS	relation/Makefile	/^PROGS =	orphan3$/;"	m
ROOT	relation/Makefile	/^ROOT=..$/;"	m
main	relation/orphan3.c	/^main(void)$/;"	f
pr_ids	relation/orphan3.c	/^pr_ids(char *name)$/;"	f	file:
sig_hup	relation/orphan3.c	/^sig_hup(int signo)$/;"	f	file:
CLD	signals/Makefile	/^  CLD = child$/;"	m
CLD	signals/Makefile	/^CLD =$/;"	m
MOREPROGS	signals/Makefile	/^MOREPROGS = systest2 tsleep2$/;"	m
PLATFORM	signals/Makefile	/^PLATFORM=$(shell $(ROOT)\/systype.sh)$/;"	m
PROGS	signals/Makefile	/^PROGS =	critical mask read1 read2 reenter sigtstp sigusr suspend1 suspend2$/;"	m
ROOT	signals/Makefile	/^ROOT=..$/;"	m
abort	signals/abort.c	/^abort(void)			\/* POSIX-style abort() function *\/$/;"	f
main	signals/child.c	/^main()$/;"	f
sig_cld	signals/child.c	/^sig_cld(int signo)	\/* interrupts pause() *\/$/;"	f	file:
main	signals/critical.c	/^main(void)$/;"	f
sig_quit	signals/critical.c	/^sig_quit(int signo)$/;"	f	file:
canjump	signals/mask.c	/^static volatile sig_atomic_t	canjump;$/;"	v	file:
jmpbuf	signals/mask.c	/^static sigjmp_buf				jmpbuf;$/;"	v	file:
main	signals/mask.c	/^main(void)$/;"	f
sig_alrm	signals/mask.c	/^sig_alrm(int signo)$/;"	f	file:
sig_usr1	signals/mask.c	/^sig_usr1(int signo)$/;"	f	file:
main	signals/read1.c	/^main(void)$/;"	f
sig_alrm	signals/read1.c	/^sig_alrm(int signo)$/;"	f	file:
env_alrm	signals/read2.c	/^static jmp_buf	env_alrm;$/;"	v	file:
main	signals/read2.c	/^main(void)$/;"	f
sig_alrm	signals/read2.c	/^sig_alrm(int signo)$/;"	f	file:
main	signals/reenter.c	/^main(void)$/;"	f
my_alarm	signals/reenter.c	/^my_alarm(int signo)$/;"	f	file:
SIGBAD	signals/setops.c	7;"	d	file:
sigaddset	signals/setops.c	/^sigaddset(sigset_t *set, int signo)$/;"	f
sigdelset	signals/setops.c	/^sigdelset(sigset_t *set, int signo)$/;"	f
sigismember	signals/setops.c	/^sigismember(const sigset_t *set, int signo)$/;"	f
BUFFSIZE	signals/sigtstp.c	3;"	d	file:
main	signals/sigtstp.c	/^main(void)$/;"	f
sig_tstp	signals/sigtstp.c	/^sig_tstp(int signo)	\/* signal handler for SIGTSTP *\/$/;"	f	file:
main	signals/sigusr.c	/^main(void)$/;"	f
sig_usr	signals/sigusr.c	/^sig_usr(int signo)		\/* argument is signal number *\/$/;"	f	file:
sig_alrm	signals/sleep1.c	/^sig_alrm(int signo)$/;"	f	file:
sleep1	signals/sleep1.c	/^sleep1(unsigned int seconds)$/;"	f
env_alrm	signals/sleep2.c	/^static jmp_buf	env_alrm;$/;"	v	file:
sig_alrm	signals/sleep2.c	/^sig_alrm(int signo)$/;"	f	file:
sleep2	signals/sleep2.c	/^sleep2(unsigned int seconds)$/;"	f
main	signals/suspend1.c	/^main(void)$/;"	f
sig_int	signals/suspend1.c	/^sig_int(int signo)$/;"	f	file:
main	signals/suspend2.c	/^main(void)$/;"	f
quitflag	signals/suspend2.c	/^volatile sig_atomic_t	quitflag;	\/* set nonzero by signal handler *\/$/;"	v
sig_int	signals/suspend2.c	/^sig_int(int signo)	\/* one signal handler for SIGINT and SIGQUIT *\/$/;"	f	file:
system	signals/system.c	/^system(const char *cmdstring)	\/* with appropriate signal handling *\/$/;"	f
main	signals/systest2.c	/^main(void)$/;"	f
sig_chld	signals/systest2.c	/^sig_chld(int signo)$/;"	f	file:
sig_int	signals/systest2.c	/^sig_int(int signo)$/;"	f	file:
main	signals/tsleep2.c	/^main(void)$/;"	f
sig_int	signals/tsleep2.c	/^sig_int(int signo)$/;"	f	file:
MAXSLEEP	sockets/clconn.c	4;"	d	file:
connect_retry	sockets/clconn.c	/^connect_retry(int sockfd, const struct sockaddr *addr, socklen_t alen)$/;"	f
MAXSLEEP	sockets/clconn2.c	4;"	d	file:
connect_retry	sockets/clconn2.c	/^connect_retry(int domain, int type, int protocol,$/;"	f
main	sockets/findsvc.c	/^main(int argc, char *argv[])$/;"	f
print_family	sockets/findsvc.c	/^print_family(struct addrinfo *aip)$/;"	f
print_flags	sockets/findsvc.c	/^print_flags(struct addrinfo *aip)$/;"	f
print_protocol	sockets/findsvc.c	/^print_protocol(struct addrinfo *aip)$/;"	f
print_type	sockets/findsvc.c	/^print_type(struct addrinfo *aip)$/;"	f
initserver	sockets/initsrv1.c	/^initserver(int type, const struct sockaddr *addr, socklen_t alen,$/;"	f
initserver	sockets/initsrv2.c	/^initserver(int type, const struct sockaddr *addr, socklen_t alen,$/;"	f
EXTRALIBS	sockets/makefile	/^  EXTRALIBS = -lsocket -lnsl$/;"	m
MOREPROGS	sockets/makefile	/^MOREPROGS = findsvc ruptime-dg$/;"	m
PLATFORM	sockets/makefile	/^PLATFORM=$(shell $(ROOT)\/systype.sh)$/;"	m
PROGS	sockets/makefile	/^PROGS = ruptime ruptimed ruptimed-fd ruptimed-dg$/;"	m
ROOT	sockets/makefile	/^ROOT=..$/;"	m
BUFLEN	sockets/ruptime-dg.c	6;"	d	file:
TIMEOUT	sockets/ruptime-dg.c	7;"	d	file:
main	sockets/ruptime-dg.c	/^main(int argc, char *argv[])$/;"	f
print_uptime	sockets/ruptime-dg.c	/^print_uptime(int sockfd, struct addrinfo *aip)$/;"	f
sigalrm	sockets/ruptime-dg.c	/^sigalrm(int signo)$/;"	f
BUFLEN	sockets/ruptime.c	6;"	d	file:
main	sockets/ruptime.c	/^main(int argc, char *argv[])$/;"	f
print_uptime	sockets/ruptime.c	/^print_uptime(int sockfd)$/;"	f
BUFLEN	sockets/ruptimed-dg.c	7;"	d	file:
HOST_NAME_MAX	sockets/ruptimed-dg.c	11;"	d	file:
MAXADDRLEN	sockets/ruptimed-dg.c	8;"	d	file:
main	sockets/ruptimed-dg.c	/^main(int argc, char *argv[])$/;"	f
serve	sockets/ruptimed-dg.c	/^serve(int sockfd)$/;"	f
HOST_NAME_MAX	sockets/ruptimed-fd.c	12;"	d	file:
QLEN	sockets/ruptimed-fd.c	9;"	d	file:
main	sockets/ruptimed-fd.c	/^main(int argc, char *argv[])$/;"	f
serve	sockets/ruptimed-fd.c	/^serve(int sockfd)$/;"	f
BUFLEN	sockets/ruptimed.c	7;"	d	file:
HOST_NAME_MAX	sockets/ruptimed.c	11;"	d	file:
QLEN	sockets/ruptimed.c	8;"	d	file:
main	sockets/ruptimed.c	/^main(int argc, char *argv[])$/;"	f
serve	sockets/ruptimed.c	/^serve(int sockfd)$/;"	f
PLATFORM	standards/Makefile	/^PLATFORM=$(shell $(ROOT)\/systype.sh)$/;"	m
PROGS	standards/Makefile	/^PROGS =	conf options$/;"	m
ROOT	standards/Makefile	/^ROOT=..$/;"	m
MEMSTR	stdio/Makefile	/^  MEMSTR = memstr$/;"	m
MEMSTR	stdio/Makefile	/^  MEMSTR =$/;"	m
PLATFORM	stdio/Makefile	/^PLATFORM=$(shell $(ROOT)\/systype.sh)$/;"	m
PROGS	stdio/Makefile	/^PROGS =	buf fgetsfputs getcharbug getcputc mkstemp tempfiles$/;"	m
ROOT	stdio/Makefile	/^ROOT=..$/;"	m
_base	stdio/buf.c	92;"	d	file:
_flag	stdio/buf.c	90;"	d	file:
_ptr	stdio/buf.c	91;"	d	file:
buffer_size	stdio/buf.c	/^buffer_size(FILE *fp)$/;"	f
is_linebuffered	stdio/buf.c	/^is_linebuffered(FILE *fp)$/;"	f
is_unbuffered	stdio/buf.c	/^is_unbuffered(FILE *fp)$/;"	f
main	stdio/buf.c	/^main(void)$/;"	f
pr_stdio	stdio/buf.c	/^pr_stdio(const char *name, FILE *fp)$/;"	f
main	stdio/fgetsfputs.c	/^main(void)$/;"	f
main	stdio/getcharbug.c	/^main(void)$/;"	f
main	stdio/getcputc.c	/^main(void)$/;"	f
BSZ	stdio/memstr.c	3;"	d	file:
main	stdio/memstr.c	/^main()$/;"	f
main	stdio/mkstemp.c	/^main()$/;"	f
make_temp	stdio/mkstemp.c	/^make_temp(char *template)$/;"	f
main	stdio/tempfiles.c	/^main(void)$/;"	f
PLATFORM	termios/Makefile	/^PLATFORM=$(shell $(ROOT)\/systype.sh)$/;"	m
PROGS	termios/Makefile	/^PROGS =	csize settty t_getpass t_isatty t_raw t_ttyname winch$/;"	m
ROOT	termios/Makefile	/^ROOT=..$/;"	m
main	termios/csize.c	/^main(void)$/;"	f
ctermid	termios/ctermid.c	/^ctermid(char *str)$/;"	f
ctermid_name	termios/ctermid.c	/^static char	ctermid_name[L_ctermid];$/;"	v	file:
MAX_PASS_LEN	termios/getpass.c	5;"	d	file:
getpass	termios/getpass.c	/^getpass(const char *prompt)$/;"	f
isatty	termios/isatty.c	/^isatty(int fd)$/;"	f
main	termios/settty.c	/^main(void)$/;"	f
main	termios/t_getpass.c	/^main(void)$/;"	f
main	termios/t_isatty.c	/^main(void)$/;"	f
main	termios/t_raw.c	/^main(void)$/;"	f
sig_catch	termios/t_raw.c	/^sig_catch(int signo)$/;"	f	file:
main	termios/t_ttyname.c	/^main(void)$/;"	f
add	termios/ttyname.c	/^add(char *dirname)$/;"	f	file:
cleanup	termios/ttyname.c	/^cleanup(void)$/;"	f	file:
d_name	termios/ttyname.c	/^	char			*d_name;$/;"	m	struct:devdir	file:
d_next	termios/ttyname.c	/^	struct devdir	*d_next;$/;"	m	struct:devdir	typeref:struct:devdir::devdir	file:
devdir	termios/ttyname.c	/^struct devdir {$/;"	s	file:
head	termios/ttyname.c	/^static struct devdir	*head;$/;"	v	typeref:struct:devdir	file:
pathname	termios/ttyname.c	/^static char				pathname[_POSIX_PATH_MAX + 1];$/;"	v	file:
searchdir	termios/ttyname.c	/^searchdir(char *dirname, struct stat *fdstatp)$/;"	f	file:
tail	termios/ttyname.c	/^static struct devdir	*tail;$/;"	v	typeref:struct:devdir	file:
ttyname	termios/ttyname.c	/^ttyname(int fd)$/;"	f
main	termios/winch.c	/^main(void)$/;"	f
pr_winsize	termios/winch.c	/^pr_winsize(int fd)$/;"	f	file:
sig_winch	termios/winch.c	/^sig_winch(int signo)$/;"	f	file:
EXTRALIBS	threadctl/Makefile	/^  EXTRALIBS = -lpthread$/;"	m
EXTRALIBS	threadctl/Makefile	/^  EXTRALIBS = -pthread$/;"	m
PLATFORM	threadctl/Makefile	/^PLATFORM=$(shell $(ROOT)\/systype.sh)$/;"	m
PROGS	threadctl/Makefile	/^PROGS =	atfork suspend$/;"	m
ROOT	threadctl/Makefile	/^ROOT=..$/;"	m
TOUT	threadctl/Makefile	/^  TOUT = timeout.o$/;"	m
TOUT	threadctl/Makefile	/^TOUT =$/;"	m
child	threadctl/atfork.c	/^child(void)$/;"	f
lock1	threadctl/atfork.c	/^pthread_mutex_t lock1 = PTHREAD_MUTEX_INITIALIZER;$/;"	v
lock2	threadctl/atfork.c	/^pthread_mutex_t lock2 = PTHREAD_MUTEX_INITIALIZER;$/;"	v
main	threadctl/atfork.c	/^main(void)$/;"	f
parent	threadctl/atfork.c	/^parent(void)$/;"	f
prepare	threadctl/atfork.c	/^prepare(void)$/;"	f
thr_fn	threadctl/atfork.c	/^thr_fn(void *arg)$/;"	f
makethread	threadctl/detach.c	/^makethread(void *(*fn)(void *), void *arg)$/;"	f
MAXSTRINGSZ	threadctl/getenv1.c	4;"	d	file:
envbuf	threadctl/getenv1.c	/^static char envbuf[MAXSTRINGSZ];$/;"	v	file:
getenv	threadctl/getenv1.c	/^getenv(const char *name)$/;"	f
env_mutex	threadctl/getenv2.c	/^pthread_mutex_t env_mutex;$/;"	v
getenv_r	threadctl/getenv2.c	/^getenv_r(const char *name, char *buf, int buflen)$/;"	f
init_done	threadctl/getenv2.c	/^static pthread_once_t init_done = PTHREAD_ONCE_INIT;$/;"	v	file:
thread_init	threadctl/getenv2.c	/^thread_init(void)$/;"	f	file:
MAXSTRINGSZ	threadctl/getenv3.c	6;"	d	file:
env_mutex	threadctl/getenv3.c	/^pthread_mutex_t env_mutex = PTHREAD_MUTEX_INITIALIZER;$/;"	v
getenv	threadctl/getenv3.c	/^getenv(const char *name)$/;"	f
init_done	threadctl/getenv3.c	/^static pthread_once_t init_done = PTHREAD_ONCE_INIT;$/;"	v	file:
key	threadctl/getenv3.c	/^static pthread_key_t key;$/;"	v	file:
thread_init	threadctl/getenv3.c	/^thread_init(void)$/;"	f	file:
lock	threadctl/suspend.c	/^pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;$/;"	v
main	threadctl/suspend.c	/^main(void)$/;"	f
mask	threadctl/suspend.c	/^sigset_t	mask;$/;"	v
quitflag	threadctl/suspend.c	/^int			quitflag;	\/* set nonzero by thread *\/$/;"	v
thr_fn	threadctl/suspend.c	/^thr_fn(void *arg)$/;"	f
waitloc	threadctl/suspend.c	/^pthread_cond_t waitloc = PTHREAD_COND_INITIALIZER;$/;"	v
CLOCK_REALTIME	threadctl/timeout.c	21;"	d	file:
SECTONSEC	threadctl/timeout.c	14;"	d	file:
USECTONSEC	threadctl/timeout.c	22;"	d	file:
attr	threadctl/timeout.c	/^pthread_mutexattr_t attr;$/;"	v
clock_gettime	threadctl/timeout.c	/^clock_gettime(int id, struct timespec *tsp)$/;"	f
clock_nanosleep	threadctl/timeout.c	17;"	d	file:
main	threadctl/timeout.c	/^main(void)$/;"	f
mutex	threadctl/timeout.c	/^pthread_mutex_t mutex;$/;"	v
retry	threadctl/timeout.c	/^retry(void *arg)$/;"	f
timeout	threadctl/timeout.c	/^timeout(const struct timespec *when, void (*func)(void *), void *arg)$/;"	f
timeout_helper	threadctl/timeout.c	/^timeout_helper(void *arg)$/;"	f
to_arg	threadctl/timeout.c	/^	void           *to_arg;			\/* argument *\/$/;"	m	struct:to_info	file:
to_fn	threadctl/timeout.c	/^	void	      (*to_fn)(void *);	\/* function *\/$/;"	m	struct:to_info	file:
to_info	threadctl/timeout.c	/^struct to_info {$/;"	s	file:
to_wait	threadctl/timeout.c	/^	struct timespec to_wait;		\/* time to wait *\/$/;"	m	struct:to_info	typeref:struct:to_info::timespec	file:
BAR	threads/Makefile	/^  BAR = barrier$/;"	m
BAR	threads/Makefile	/^BAR =$/;"	m
EXTRALIBS	threads/Makefile	/^  EXTRALIBS=-lpthread -lrt$/;"	m
EXTRALIBS	threads/Makefile	/^  EXTRALIBS=-pthread -lrt -lbsd$/;"	m
EXTRALIBS	threads/Makefile	/^  EXTRALIBS=-pthread$/;"	m
EXTRALIBS	threads/Makefile	/^EXTRALIBS=-pthread$/;"	m
PLATFORM	threads/Makefile	/^PLATFORM=$(shell $(ROOT)\/systype.sh)$/;"	m
PROGS	threads/Makefile	/^PROGS = badexit2 cleanup exitstatus threadid$/;"	m
ROOT	threads/Makefile	/^ROOT=..$/;"	m
TLOCK	threads/Makefile	/^  TLOCK = timedlock$/;"	m
TLOCK	threads/Makefile	/^  TLOCK =$/;"	m
a	threads/badexit2.c	/^	int a, b, c, d;$/;"	m	struct:foo	file:
b	threads/badexit2.c	/^	int a, b, c, d;$/;"	m	struct:foo	file:
c	threads/badexit2.c	/^	int a, b, c, d;$/;"	m	struct:foo	file:
d	threads/badexit2.c	/^	int a, b, c, d;$/;"	m	struct:foo	file:
foo	threads/badexit2.c	/^struct foo {$/;"	s	file:
main	threads/badexit2.c	/^main(void)$/;"	f
printfoo	threads/badexit2.c	/^printfoo(const char *s, const struct foo *fp)$/;"	f
thr_fn1	threads/badexit2.c	/^thr_fn1(void *arg)$/;"	f
thr_fn2	threads/badexit2.c	/^thr_fn2(void *arg)$/;"	f
NTHR	threads/barrier.c	6;"	d	file:
NUMNUM	threads/barrier.c	7;"	d	file:
TNUM	threads/barrier.c	8;"	d	file:
b	threads/barrier.c	/^pthread_barrier_t b;$/;"	v
complong	threads/barrier.c	/^complong(const void *arg1, const void *arg2)$/;"	f
heapsort	threads/barrier.c	16;"	d	file:
main	threads/barrier.c	/^main()$/;"	f
merge	threads/barrier.c	/^merge()$/;"	f
nums	threads/barrier.c	/^long nums[NUMNUM];$/;"	v
snums	threads/barrier.c	/^long snums[NUMNUM];$/;"	v
thr_fn	threads/barrier.c	/^thr_fn(void *arg)$/;"	f
cleanup	threads/cleanup.c	/^cleanup(void *arg)$/;"	f
main	threads/cleanup.c	/^main(void)$/;"	f
thr_fn1	threads/cleanup.c	/^thr_fn1(void *arg)$/;"	f
thr_fn2	threads/cleanup.c	/^thr_fn2(void *arg)$/;"	f
enqueue_msg	threads/condvar.c	/^enqueue_msg(struct msg *mp)$/;"	f
m_next	threads/condvar.c	/^	struct msg *m_next;$/;"	m	struct:msg	typeref:struct:msg::msg	file:
msg	threads/condvar.c	/^struct msg {$/;"	s	file:
process_msg	threads/condvar.c	/^process_msg(void)$/;"	f
qlock	threads/condvar.c	/^pthread_mutex_t qlock = PTHREAD_MUTEX_INITIALIZER;$/;"	v
qready	threads/condvar.c	/^pthread_cond_t qready = PTHREAD_COND_INITIALIZER;$/;"	v
workq	threads/condvar.c	/^struct msg *workq;$/;"	v	typeref:struct:msg
main	threads/exitstatus.c	/^main(void)$/;"	f
thr_fn1	threads/exitstatus.c	/^thr_fn1(void *arg)$/;"	f
thr_fn2	threads/exitstatus.c	/^thr_fn2(void *arg)$/;"	f
maketimeout	threads/maketimeout.c	/^maketimeout(struct timespec *tsp, long minutes)$/;"	f
f_count	threads/mutex1.c	/^	int             f_count;$/;"	m	struct:foo	file:
f_id	threads/mutex1.c	/^	int             f_id;$/;"	m	struct:foo	file:
f_lock	threads/mutex1.c	/^	pthread_mutex_t f_lock;$/;"	m	struct:foo	file:
foo	threads/mutex1.c	/^struct foo {$/;"	s	file:
foo_alloc	threads/mutex1.c	/^foo_alloc(int id) \/* allocate the object *\/$/;"	f
foo_hold	threads/mutex1.c	/^foo_hold(struct foo *fp) \/* add a reference to the object *\/$/;"	f
foo_rele	threads/mutex1.c	/^foo_rele(struct foo *fp) \/* release a reference to the object *\/$/;"	f
HASH	threads/mutex2.c	5;"	d	file:
NHASH	threads/mutex2.c	4;"	d	file:
f_count	threads/mutex2.c	/^	int             f_count;$/;"	m	struct:foo	file:
f_id	threads/mutex2.c	/^	int             f_id;$/;"	m	struct:foo	file:
f_lock	threads/mutex2.c	/^	pthread_mutex_t f_lock;$/;"	m	struct:foo	file:
f_next	threads/mutex2.c	/^	struct foo     *f_next; \/* protected by hashlock *\/$/;"	m	struct:foo	typeref:struct:foo::foo	file:
fh	threads/mutex2.c	/^struct foo *fh[NHASH];$/;"	v	typeref:struct:foo
foo	threads/mutex2.c	/^struct foo {$/;"	s	file:
foo_alloc	threads/mutex2.c	/^foo_alloc(int id) \/* allocate the object *\/$/;"	f
foo_find	threads/mutex2.c	/^foo_find(int id) \/* find an existing object *\/$/;"	f
foo_hold	threads/mutex2.c	/^foo_hold(struct foo *fp) \/* add a reference to the object *\/$/;"	f
foo_rele	threads/mutex2.c	/^foo_rele(struct foo *fp) \/* release a reference to the object *\/$/;"	f
hashlock	threads/mutex2.c	/^pthread_mutex_t hashlock = PTHREAD_MUTEX_INITIALIZER;$/;"	v
HASH	threads/mutex3.c	5;"	d	file:
NHASH	threads/mutex3.c	4;"	d	file:
f_count	threads/mutex3.c	/^	int             f_count; \/* protected by hashlock *\/$/;"	m	struct:foo	file:
f_id	threads/mutex3.c	/^	int             f_id;$/;"	m	struct:foo	file:
f_lock	threads/mutex3.c	/^	pthread_mutex_t f_lock;$/;"	m	struct:foo	file:
f_next	threads/mutex3.c	/^	struct foo     *f_next; \/* protected by hashlock *\/$/;"	m	struct:foo	typeref:struct:foo::foo	file:
fh	threads/mutex3.c	/^struct foo *fh[NHASH];$/;"	v	typeref:struct:foo
foo	threads/mutex3.c	/^struct foo {$/;"	s	file:
foo_alloc	threads/mutex3.c	/^foo_alloc(int id) \/* allocate the object *\/$/;"	f
foo_find	threads/mutex3.c	/^foo_find(int id) \/* find an existing object *\/$/;"	f
foo_hold	threads/mutex3.c	/^foo_hold(struct foo *fp) \/* add a reference to the object *\/$/;"	f
foo_rele	threads/mutex3.c	/^foo_rele(struct foo *fp) \/* release a reference to the object *\/$/;"	f
hashlock	threads/mutex3.c	/^pthread_mutex_t hashlock = PTHREAD_MUTEX_INITIALIZER;$/;"	v
j_id	threads/rwlock.c	/^	pthread_t   j_id;   \/* tells which thread handles this job *\/$/;"	m	struct:job	file:
j_next	threads/rwlock.c	/^	struct job *j_next;$/;"	m	struct:job	typeref:struct:job::job	file:
j_prev	threads/rwlock.c	/^	struct job *j_prev;$/;"	m	struct:job	typeref:struct:job::job	file:
job	threads/rwlock.c	/^struct job {$/;"	s	file:
job_append	threads/rwlock.c	/^job_append(struct queue *qp, struct job *jp)$/;"	f
job_find	threads/rwlock.c	/^job_find(struct queue *qp, pthread_t id)$/;"	f
job_insert	threads/rwlock.c	/^job_insert(struct queue *qp, struct job *jp)$/;"	f
job_remove	threads/rwlock.c	/^job_remove(struct queue *qp, struct job *jp)$/;"	f
q_head	threads/rwlock.c	/^	struct job      *q_head;$/;"	m	struct:queue	typeref:struct:queue::job	file:
q_lock	threads/rwlock.c	/^	pthread_rwlock_t q_lock;$/;"	m	struct:queue	file:
q_tail	threads/rwlock.c	/^	struct job      *q_tail;$/;"	m	struct:queue	typeref:struct:queue::job	file:
queue	threads/rwlock.c	/^struct queue {$/;"	s	file:
queue_init	threads/rwlock.c	/^queue_init(struct queue *qp)$/;"	f
main	threads/threadid.c	/^main(void)$/;"	f
ntid	threads/threadid.c	/^pthread_t ntid;$/;"	v
printids	threads/threadid.c	/^printids(const char *s)$/;"	f
thr_fn	threads/threadid.c	/^thr_fn(void *arg)$/;"	f
main	threads/timedlock.c	/^main(void)$/;"	f
